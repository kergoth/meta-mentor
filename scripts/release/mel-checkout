#!/bin/sh

set -eu

prompt_choice () {
    prompt_message="$1"
    prompt_default="${2:-}"

    prompt_options="$(mktemp prompt-choice.XXXXXX)"
    cat >>"$prompt_options"

    prompt_count="$(wc -l <"$prompt_options")"
    case $prompt_count in
        0)
            # No choices provided
            rm -f "$prompt_options"
            return 1
            ;;
        1)
            # Only one choice
            cat "$prompt_options"
            rm -f "$prompt_options"
            return 0
            ;;
    esac

    if [ ! -t 0 ] || [ ! -t 2 ]; then
        # We only prompt when running on a tty
        return 2
    fi

    if [ -n "$prompt_default" ] && \
            ! echo "$prompt_default" | grep -q '^[0-9]*'; then
        printf >&2 'Error: prompt_default value '%s' is invalid, default must be a selection number.\n' "$prompt_default"
        prompt_default=
    fi

    prompt_value=
    while [ -z "$prompt_value" ]; do
        prompt_num=0
        while read choice; do
            prompt_num=$(expr $prompt_num + 1)
            eval prompt_value_${prompt_num}="$choice"
            printf >&2 "%s) %s\n" "$prompt_num" "$choice"
        done <"$prompt_options"

        if [ -n "$prompt_default" ]; then
            printf >&2 "%s [%s]: " "$prompt_message" "$prompt_default"
        else
            printf >&2 "%s: " "$prompt_message"
        fi
        read selection </dev/tty
        prompt_value="$(eval echo \${prompt_value_$selection})"
        if [ -n "$prompt_default" ] && [ -z "$prompt_value" ]; then
            prompt_value="$(eval echo \${prompt_value_$prompt_default})"
        fi
    done
    printf "%s\n" "$prompt_value"
    rm -f "$prompt_options"
}

prompt_manifest() {
    find "$1" -maxdepth 1 -type f -name \*.manifest | \
        sed 's,^.*/,,' | sort -rn | \
        ( set +u; prompt_choice "$2" 1; ) | sed "s,^,$1/,"
}


if [ $# -eq 0 ] || [ "$1" = "-h" ]; then
    echo >&2 "Usage: ${0##*/} BUILD_DIR [MANIFEST_FILE [EXTRA_MANIFEST_FILES..]]"
    echo >&2
    echo >&2 "If no manifest file is specified, a prompt will be shown to"
    echo >&2 "interactively select one of the manifests in the same mel"
    echo >&2 "installation as this script. If no extra manifest files are"
    echo >&2 "specified, a prompt will be shown for each type."
    exit 1
fi

scriptdir="$(cd "$(dirname "$0")" && pwd -P)"
project="$1"
shift

mkdir -p "$project"
cd "$project"

manifest="$1"
if [ -z "$1" ]; then
    if ! [ -e "$project/.manifest" ]; then
        prompt_manifest "$scriptdir/manifests" "Select manifest" >"$project/.manifest"
        if ! [ -s "$project/.manifest" ]; then
            echo >&2 "Error: no manifest found, please specify"
            rm -f "$project/.manifest"
            exit 1
        fi
    fi
    set -- $(cat "$project/.manifest")
    manifest="$1"
else
    echo "$manifest" >"$project/.manifest"
fi

if [ $# -lt 2 ]; then
    extra_base="$scriptdir/manifests/extra"
    for extra_dir in "$extra_base"/*/; do
        if [ -d "$extra_dir" ]; then
            extra_dir="${extra_dir%/}"
            name="${extra_dir#$extra_base/}"
            extra_manifest="$(prompt_manifest "$extra_dir" "Select manifest for $name")"
            if [ -z "$extra_manifest" ]; then
                echo >&2 "Error: no extra manifest for $name?"
                exit 1
            else
                set -- "$@" "$extra_manifest"
                echo "$extra_manifest" >>"$project/.manifest"
            fi
        fi
    done
elif [ "$2" = "" ]; then
    # Extra manifests explicitly disabled, do not prompt or use
    set -- "$1"
fi

cat "$@" | sort -u | while read -r checkout_path commit remotes; do
    if [ ! -d "$checkout_path/.git" ]; then
        git init "$checkout_path"
    fi

    cd "$checkout_path"
    echo "$scriptdir/objects" >.git/objects/info/alternates
    echo "$commit" >.git/shallow

    echo "$remotes" | tr '\t' '\n' | while IFS== read -r name url; do
        if [ -n "$name" ]; then
            if git remote | grep -qxF "$name"; then
                git remote set-url "$name" "$url"
            else
                git remote add "$name" "$url"
            fi
        fi
    done

    # Create branches for all manifests, for reference
    for otherfn in "$scriptdir/manifests/"*.manifest; do
        while read -r other_checkout_path other_commit _; do
            if [ "$other_checkout_path" = "$checkout_path" ]; then
                branch="$(basename "${otherfn%.manifest}")"
                if ! git rev-parse -q --verify "refs/heads/$branch" >/dev/null; then
                    git update-ref "refs/heads/$branch" "$other_commit"
                fi
                echo "$other_commit" >>.git/shallow
            fi
        done <"$otherfn"
    done
    branch="$(basename "${manifest%.manifest}")"
    if ! git rev-parse -q --verify "refs/heads/$branch" >/dev/null; then
        git update-ref "refs/heads/$branch" "$commit"
    fi
    if [ "$(git rev-parse -q --verify --symbolic-full-name HEAD 2>/dev/null)" != "refs/heads/$branch" ]; then
        git checkout "$branch"
    fi

    cd - >/dev/null
done

if [ -e "${manifest%.manifest}.info" ]; then
    bspfiles_path="$(sed -n -e 's/^bspfiles_path = //p' "${manifest%.manifest}.info")"
    if [ -n "$bspfiles_path" ] && [ -e "$scriptdir/$bspfiles_path" ]; then
        rm -f "${bspfiles_path%/*}"
        ln -s "$scriptdir/$bspfiles_path" "${bspfiles_path%/*}"
    fi
fi

for dir in downloads cached-binaries; do
    if [ -e "$scriptdir/$dir" ]; then
        ln -sf "$scriptdir/$dir" . || :
    fi
done
