#!/bin/sh

prompt_choice () {
    prompt_message="$1"
    prompt_default="$2"

    prompt_options="$(mktemp prompt-choice.XXXXXX)"
    cat >>"$prompt_options"

    prompt_count="$(wc -l <"$prompt_options")"
    case $prompt_count in
        0)
            # No choices provided
            rm -f "$prompt_options"
            return 1
            ;;
        1)
            # Only one choice
            cat "$prompt_options"
            rm -f "$prompt_options"
            return 0
            ;;
    esac

    if [ ! -t 0 ] || [ ! -t 2 ]; then
        # We only prompt when running on a tty
        return 2
    fi

    while [ -z "$prompt_value" ]; do
        prompt_num=0
        while read choice; do
            prompt_num=$(expr $prompt_num + 1)
            eval prompt_value_${prompt_num}="$choice"
            printf >&2 "%s) %s\n" "$prompt_num" "$choice"
        done <"$prompt_options"
        printf >&2 "%s: " "$prompt_message"
        read selection </dev/tty
        prompt_value="$(eval echo \${prompt_value_$selection})"
    done
    printf "%s\n" "$prompt_value"
    rm -f "$prompt_options"
}

scriptdir="$(cd "$(dirname "$0")" && pwd -P)"
project="$1"
manifest="$2"

if [ -z "$manifest" ]; then
    if [ -e "$project/.manifest" ]; then
        manifest="$(cat "$project/.manifest")"
        echo >&2 "Using manifest $manifest for $project"
    else
        tmpfile="$(mktemp -t "${0##*/}.XXXXX")"
        trap 'rm -f "$tmpfile"' EXIT INT TERM
        find "$scriptdir/manifests" -maxdepth 1 -type f -name \*.manifest | \
            sed 's,^.*/,,' | prompt_choice "Select manifest" >$tmpfile
        manifest="$(cat "$tmpfile")"
        if [ -z "$manifest" ]; then
            echo >&2 "Error: no manifest found, please specify"
            exit 1
        fi
    fi
fi

mkdir -p "$project"
cd "$project"
{
    cat "$scriptdir/manifests/$manifest"
    find "$scriptdir/manifests/extra" -type f -name \*.manifest 2>/dev/null | \
        while read -r fn; do
            cat "$fn"
        done
} | while read -r checkout_path pack commit remote; do
    git init "$checkout_path"
    cd "$checkout_path"
    echo "$scriptdir/objects" >.git/objects/info/alternates
    echo "$commit" >.git/shallow
    if [ -n "$remote" ]; then
        git remote add origin "$remote"
    fi
    git checkout -b "$(basename "${manifest%.manifest}")" "$commit"

    # Create branches for any other manifests, for reference
    for otherfn in "$scriptdir/manifests/"*.manifest; do
        if [ "$otherfn" != "$scriptdir/manifests/$manifest" ]; then
            while read -r other_checkout_path _ other_commit _; do
                if [ "$other_checkout_path" = "$checkout_path" ]; then
                    git branch "$(basename "${otherfn%.manifest}")" "$other_commit"
                    echo "$other_commit" >>.git/shallow
                fi
            done <"$otherfn"
        fi
    done
    cd - >/dev/null
done
echo "$manifest" >.manifest

for dir in downloads cached-binaries; do
    if [ -e "$scriptdir/$dir" ]; then
        ln -sf "$scriptdir/$dir" .
    fi
done

if [ -e "$scriptdir/manifests/${manifest%.manifest}.info" ]; then
    bspfiles_path="$(sed -n -e 's/^bspfiles_path = //p' "$scriptdir/manifests/${manifest%.manifest}.info")"
else
    bspfiles_path=
fi
if [ -n "$bspfiles_path" ]; then
    if [ -e "$scriptdir/$bspfiles_path" ]; then
        mkdir -p "$(dirname "$bspfiles_path")"
        ln -sf "$scriptdir/$bspfiles_path" "$bspfiles_path"
    else
        echo >&2 "Warning: specified bspfiles_path from ${manifest%.manifest}.info does not exist"
        for i in "$scriptdir"/*/*/conf/local.conf.sample; do
            ln -sf "${i%/*/conf/local.conf.sample}" .
        done
    fi
else
    for i in "$scriptdir"/*/*/conf/local.conf.sample; do
        ln -sf "${i%/*/conf/local.conf.sample}" .
    done
fi
