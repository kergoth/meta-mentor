#!/bin/sh

prompt_choice () {
    prompt_message="$1"
    prompt_default="$2"

    prompt_options="$(mktemp prompt-choice.XXXXXX)"
    cat >>"$prompt_options"

    prompt_count="$(wc -l <"$prompt_options")"
    case $prompt_count in
        0)
            # No choices provided
            rm -f "$prompt_options"
            return 1
            ;;
        1)
            # Only one choice
            cat "$prompt_options"
            rm -f "$prompt_options"
            return 0
            ;;
    esac

    if [ ! -t 0 ] || [ ! -t 2 ]; then
        # We only prompt when running on a tty
        return 2
    fi

    while [ -z "$prompt_value" ]; do
        prompt_num=0
        while read choice; do
            prompt_num=$(expr $prompt_num + 1)
            eval prompt_value_${prompt_num}="$choice"
            printf >&2 "%s) %s\n" "$prompt_num" "$choice"
        done <"$prompt_options"
        printf >&2 "%s: " "$prompt_message"
        read selection </dev/tty
        prompt_value="$(eval echo \${prompt_value_$selection})"
    done
    printf "%s\n" "$prompt_value"
    rm -f "$prompt_options"
}

scriptdir="$(cd "$(dirname "$0")" && pwd -P)"
project="$1"
manifest="$2"

if [ -z "$manifest" ]; then
    if [ -e "$project/.manifest" ]; then
        manifest="$(cat "$project/.manifest")"
        echo >&2 "Using manifest $manifest for $project"
    else
        tmpfile="$(mktemp -t "${0##*/}.XXXXX")"
        trap 'rm -f "$tmpfile"' EXIT INT TERM
        find "$scriptdir/manifests" -maxdepth 1 -type f -name \*.manifest | \
            sed 's,^.*/,,' | prompt_choice "Select manifest" >$tmpfile
        manifest="$(cat "$tmpfile")"
        if [ -z "$manifest" ]; then
            echo >&2 "Error: no manifest found, please specify"
            exit 1
        fi
    fi
fi

mkdir -p "$project"
cd "$project"
{
    cat "$manifest"
    cat "$scriptdir/manifests/extra/"*.manifest 2>/dev/null || :
} | sort -u | while read -r checkout_path commit remote; do
    git init "$checkout_path"
    cd "$checkout_path"
    echo "$scriptdir/objects" >.git/objects/info/alternates
    echo "$commit" >.git/shallow
    if [ -n "$remote" ]; then
        git remote add origin "$remote"
    fi
    git checkout -b "$(basename "${manifest%.manifest}")" "$commit"

    # Create branches for any other manifests, for reference
    for otherfn in "$scriptdir/manifests/"*.manifest; do
        if [ "$otherfn" != "$manifest" ]; then
            while read -r other_checkout_path other_commit _; do
                if [ "$other_checkout_path" = "$checkout_path" ]; then
                    git branch "$(basename "${otherfn%.manifest}")" "$other_commit"
                    echo "$other_commit" >>.git/shallow
                fi
            done <"$otherfn"
        fi
    done
    cd - >/dev/null
done
echo "$manifest" >.manifest

for dir in downloads cached-binaries; do
    if [ -e "$scriptdir/$dir" ]; then
        ln -sf "$scriptdir/$dir" .
    fi
done

if [ -e "${manifest%.manifest}.info" ]; then
    bspfiles_path="$(sed -n -e 's/^bspfiles_path = //p' "${manifest%.manifest}.info")"
    if [ -n "$bspfiles_path" ] && [ -e "$scriptdir/$bspfiles_path" ]; then
        rm -f "${bspfiles_path%/*}"
        ln -s "$scriptdir/$bspfiles_path" "${bspfiles_path%/*}"
    fi
fi
