#!/bin/sh

set -eu

prompt_choice () {
    prompt_message="$1"
    prompt_default="${2:-}"

    prompt_options="$(mktemp prompt-choice.XXXXXX)"
    cat >>"$prompt_options"

    prompt_count="$(wc -l <"$prompt_options")"
    case $prompt_count in
        0)
            # No choices provided
            rm -f "$prompt_options"
            return 1
            ;;
        1)
            # Only one choice
            cat "$prompt_options"
            rm -f "$prompt_options"
            return 0
            ;;
    esac

    if [ ! -t 0 ] || [ ! -t 2 ]; then
        # We only prompt when running on a tty
        return 2
    fi

    if [ -n "$prompt_default" ] && \
            ! echo "$prompt_default" | grep -q '^[0-9]*'; then
        printf >&2 'Error: prompt_default value '%s' is invalid, default must be a selection number.\n' "$prompt_default"
        prompt_default=
    fi

    prompt_value=
    while [ -z "$prompt_value" ]; do
        prompt_num=0
        while read choice; do
            prompt_num=$(expr $prompt_num + 1)
            eval prompt_value_${prompt_num}="$choice"
            printf >&2 "%s) %s\n" "$prompt_num" "$choice"
        done <"$prompt_options"

        if [ -n "$prompt_default" ]; then
            printf >&2 "%s [%s]: " "$prompt_message" "$prompt_default"
        else
            printf >&2 "%s: " "$prompt_message"
        fi
        read selection </dev/tty
        prompt_value="$(eval echo \${prompt_value_$selection})"
        if [ -n "$prompt_default" ] && [ -z "$prompt_value" ]; then
            prompt_value="$(eval echo \${prompt_value_$prompt_default})"
        fi
    done
    printf "%s\n" "$prompt_value"
    rm -f "$prompt_options"
}

if [ $# -eq 0 ] || [ "$1" = "-h" ]; then
    echo >&2 "Usage: ${0##*/} BUILD_DIR [MANIFEST_FILE]"
    echo >&2
    echo >&2 "If no manifest file is specified, a prompt will be shown to"
    echo >&2 "interactively select one of the manifests in the same mel"
    echo >&2 "installation as this script."
    exit 1
fi

scriptdir="$(cd "$(dirname "$0")" && pwd -P)"
project="$1"
manifest="${2:-}"

mkdir -p "$project"
cd "$project"

if [ -z "$manifest" ]; then
    if ! [ -e "$project/.manifest" ]; then
        find "$scriptdir/manifests" -maxdepth 1 -type f -name \*.manifest | \
            sed 's,^.*/,,' | sort -rn | ( set +u; prompt_choice "Select manifest" 1; ) | sed "s,^,$scriptdir/manifests/," >"$project/.manifest"
        if ! [ -s "$project/.manifest" ]; then
            echo >&2 "Error: no manifest found, please specify"
            rm -f "$project/.manifest"
            exit 1
        fi
    fi
    manifest="$(cat "$project/.manifest")"
    echo >&2 "Using manifest $manifest for $project"
else
    echo "$manifest" >"$project/.manifest"
fi

{
    cat "$manifest"
    cat "$scriptdir/manifests/extra/"*.manifest 2>/dev/null || :
} | sort -u | while read -r checkout_path commit remote; do
    if [ ! -d "$checkout_path/.git" ]; then
        git init "$checkout_path"
    fi

    cd "$checkout_path"
    echo "$scriptdir/objects" >.git/objects/info/alternates
    echo "$commit" >.git/shallow
    if [ -n "$remote" ]; then
        if git remote | grep -qxF origin; then
            git remote set-url origin "$remote"
        else
            git remote add origin "$remote"
        fi
    fi

    # Create branches for all manifests, for reference
    for otherfn in "$scriptdir/manifests/"*.manifest; do
        while read -r other_checkout_path other_commit _; do
            if [ "$other_checkout_path" = "$checkout_path" ]; then
                branch="$(basename "${otherfn%.manifest}")" 
                if ! git rev-parse -q --verify "refs/heads/$branch" >/dev/null; then
                    git update-ref "refs/heads/$branch" "$other_commit"
                fi
                echo "$other_commit" >>.git/shallow
            fi
        done <"$otherfn"
    done
    branch="$(basename "${manifest%.manifest}")"
    if ! git rev-parse -q --verify "refs/heads/$branch" >/dev/null; then
        git update-ref "refs/heads/$branch" "$commit"
    fi
    if [ "$(git rev-parse -q --verify --symbolic-full-name HEAD 2>/dev/null)" != "refs/heads/$branch" ]; then
        git checkout "$branch"
    fi

    cd - >/dev/null
done

if [ -e "${manifest%.manifest}.info" ]; then
    bspfiles_path="$(sed -n -e 's/^bspfiles_path = //p' "${manifest%.manifest}.info")"
    if [ -n "$bspfiles_path" ] && [ -e "$scriptdir/$bspfiles_path" ]; then
        rm -f "${bspfiles_path%/*}"
        ln -s "$scriptdir/$bspfiles_path" "${bspfiles_path%/*}"
    fi
fi

for dir in downloads cached-binaries; do
    if [ -e "$scriptdir/$dir" ]; then
        ln -sf "$scriptdir/$dir" . || :
    fi
done
